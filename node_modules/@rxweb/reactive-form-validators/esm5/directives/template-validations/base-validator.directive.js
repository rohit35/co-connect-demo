import * as tslib_1 from "tslib";
import { Input } from "@angular/core";
import { INPUT, SELECT, CHECKBOX, TEXTAREA, RADIO, FILE, CHANGE } from "../../const";
import { ControlExpressionProcess } from './control-expression-process';
var BaseValidator = /** @class */ (function (_super) {
    tslib_1.__extends(BaseValidator, _super);
    function BaseValidator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.validators = [];
        return _this;
    }
    BaseValidator.prototype.validation = function (control) {
        var e_1, _a;
        var result = null;
        try {
            for (var _b = tslib_1.__values(this.validators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var validator = _c.value;
                result = validator(control);
                if (result)
                    break;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!result && this.maskProvider)
            result = this.maskProvider.validate();
        return result;
    };
    BaseValidator.prototype.setEventName = function () {
        var eventName = '';
        switch (this.element.tagName) {
            case INPUT:
            case TEXTAREA:
                eventName = (this.element.type == CHECKBOX || this.element.type == RADIO || this.element.type == FILE) ? CHANGE : INPUT;
                break;
            case SELECT:
                eventName = CHANGE;
                break;
        }
        this.eventName = eventName.toLowerCase();
    };
    tslib_1.__decorate([
        Input()
    ], BaseValidator.prototype, "formControl", void 0);
    return BaseValidator;
}(ControlExpressionProcess));
export { BaseValidator };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS12YWxpZGF0b3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHJ4d2ViL3JlYWN0aXZlLWZvcm0tdmFsaWRhdG9ycy8iLCJzb3VyY2VzIjpbImRpcmVjdGl2ZXMvdGVtcGxhdGUtdmFsaWRhdGlvbnMvYmFzZS12YWxpZGF0b3IuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFBO0FBRXJDLE9BQU8sRUFDSCxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQ2pDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUN0QixNQUFNLGFBQWEsQ0FBQztBQUVyQixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQTtBQUd2RTtJQUFtQyx5Q0FBd0I7SUFBM0Q7UUFBQSxxRUFxQ0M7UUFsQ2EsZ0JBQVUsR0FBbUIsRUFBRSxDQUFDOztJQWtDOUMsQ0FBQztJQTdCRyxrQ0FBVSxHQUFWLFVBQVcsT0FBd0I7O1FBQy9CLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQzs7WUFDbEIsS0FBc0IsSUFBQSxLQUFBLGlCQUFBLElBQUksQ0FBQyxVQUFVLENBQUEsZ0JBQUEsNEJBQUU7Z0JBQWxDLElBQUksU0FBUyxXQUFBO2dCQUNkLE1BQU0sR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzVCLElBQUksTUFBTTtvQkFDTixNQUFNO2FBQ2I7Ozs7Ozs7OztRQUNELElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVk7WUFDN0IsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDekMsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUdTLG9DQUFZLEdBQXRCO1FBQ0ksSUFBSSxTQUFTLEdBQVcsRUFBRSxDQUFDO1FBQzNCLFFBQVEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7WUFDMUIsS0FBSyxLQUFLLENBQUM7WUFDWCxLQUFLLFFBQVE7Z0JBQ1QsU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7Z0JBQ3hILE1BQU07WUFDVixLQUFLLE1BQU07Z0JBQ1AsU0FBUyxHQUFHLE1BQU0sQ0FBQztnQkFDbkIsTUFBTTtTQUNiO1FBQ0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDN0MsQ0FBQztJQWhDUTtRQUFSLEtBQUssRUFBRTtzREFBNEM7SUFvQ3hELG9CQUFDO0NBQUEsQUFyQ0QsQ0FBbUMsd0JBQXdCLEdBcUMxRDtTQXJDWSxhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5wdXQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiXHJcbmltcG9ydCB7ICBWYWxpZGF0b3JGbiwgQWJzdHJhY3RDb250cm9sLCBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHtcclxuICAgIElOUFVULCBTRUxFQ1QsIENIRUNLQk9YLCBURVhUQVJFQSwgXHJcbiAgICBSQURJTywgRklMRSwgQ0hBTkdFXHJcbn0gZnJvbSBcIi4uLy4uL2NvbnN0XCI7XHJcblxyXG5pbXBvcnQgeyBDb250cm9sRXhwcmVzc2lvblByb2Nlc3MgfSBmcm9tICcuL2NvbnRyb2wtZXhwcmVzc2lvbi1wcm9jZXNzJ1xyXG5pbXBvcnQgeyBNYXNrUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kb21haW4vZWxlbWVudC1wcm9jZXNzb3IvbWFzay5wcm92aWRlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgQmFzZVZhbGlkYXRvciBleHRlbmRzIENvbnRyb2xFeHByZXNzaW9uUHJvY2VzcyB7XHJcbiAgICBASW5wdXQoKSBmb3JtQ29udHJvbDogRm9ybUNvbnRyb2wgfCBBYnN0cmFjdENvbnRyb2w7XHJcblxyXG4gICAgcHJvdGVjdGVkIHZhbGlkYXRvcnM6IFZhbGlkYXRvckZuW10gID0gW107XHJcbiAgICBwcm90ZWN0ZWQgZWxlbWVudDogYW55O1xyXG4gICAgcHJvdGVjdGVkIGV2ZW50TmFtZTogc3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIG1hc2tQcm92aWRlcjogTWFza1Byb3ZpZGVyO1xyXG5cclxuICAgIHZhbGlkYXRpb24oY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgdmFsaWRhdG9yIG9mIHRoaXMudmFsaWRhdG9ycykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB2YWxpZGF0b3IoY29udHJvbCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgdGhpcy5tYXNrUHJvdmlkZXIpXHJcbiAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXNrUHJvdmlkZXIudmFsaWRhdGUoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2V0RXZlbnROYW1lKCkge1xyXG4gICAgICAgIHZhciBldmVudE5hbWU6IHN0cmluZyA9ICcnO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5lbGVtZW50LnRhZ05hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSBJTlBVVDpcclxuICAgICAgICAgICAgY2FzZSBURVhUQVJFQTpcclxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9ICh0aGlzLmVsZW1lbnQudHlwZSA9PSBDSEVDS0JPWCB8fCB0aGlzLmVsZW1lbnQudHlwZSA9PSBSQURJTyB8fCB0aGlzLmVsZW1lbnQudHlwZSA9PSBGSUxFKSA/IENIQU5HRSA6IElOUFVUO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU0VMRUNUOlxyXG4gICAgICAgICAgICAgICAgZXZlbnROYW1lID0gQ0hBTkdFO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn1cclxuIl19